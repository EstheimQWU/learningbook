# fp-d02
## 内置序列类型
容器序列：list、tuple、collections.deque
扁平序列：str、bytes、bytearray、memoryview、array.arry

## 列表推导与生成器表达式
列表推导计算笛卡尔积
作为**不可变列表**与**记录**的元素、具名元组（collections.namedtuple）
多维切片与省略
由列表组成的列表
序列的增量赋值
> 总体来讲，可变序列一般都实现了__iadd__方法，因此+=是就地加法。而不可变序列根本就不支持这个操作，对这个方法的实现也就无从谈起。
> 在对不可变序列进行赋值的时候不能使用`+`拼接，否则会效率低下。

> 对字符串的拼接不应该使用`+`，但是字符串类型使用`+`已经成为了一种惯性。

如果在python解释器中运行如下的代码，会同时出现后面的两种情况。
```python
>>> t = (1, 2, [30 ,40])
>>> t[2] += [50 ,60]
```
1. 出错，`TypeError: 'tuple' object does not support item assignment`
2. `>>> t`打印->`(1, 2, [30, 40, 50, 6o])`
这两个情况是同时存在的，也就是报完错的同时，他依然去做了这个增量赋值。

1、不要把可变对象放在不可变容器中（例如元组）
2、增量赋值不是一个原子操作。可能出现部分完成，部分无法完成的情况。
3、查看python字节码有利于搞清发生了什么。（python tutor）

## list.sort/sorted/返回值None
如果一个函数或者方法就地改动对象，而且并未产生新的对象，那么就应该返回一个None，以告诉调用者知道传入的参数发生了变动，而且并未产生新的对象。

list.sort返回None，在原有列表的基础上对列表元素进行排序，而没有创建的新列表。**这个方法在python3.4之后废弃了**
sorted方法可以接收任何形式的可迭代对象作为参数（包括不可变序列与生成器），然后新建一个列表并返回这个列表。
reverse->`True`，被排序列元素会以降序输出，默认为false（也就是默认升序）。
key一个只有一个参数的函数。

## bisect
bisect二分查找
bisect.insort(seq, item)把变量item插入到序列seq中，并且保持排序。

## python中的数组，在list不是首选的时候

## memoryview 内存视图

## NumPy和SciPy

## 双向队列与其他队列
